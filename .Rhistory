Nd_0 = 0,
solve_time = solve_time,
num_index = length(solve_time),
time_index = time_index,
dpBMT = data_time,
counts = counts_sorted$total_counts,
Nfd = Nfd_sorted$Nfd,
numPred = length(ts_pred),
ts_pred = ts_pred,
theta0 = exp(source_list$theta0),
nu = source_list$nu,
chiEst = source_list$chiEst,
qEst = source_list$qEst
)
## create initial estimates
init <- function() list(
psi = exp(rnorm(1, log(0.5), 0.2)),
lambda = exp(rnorm(1,log(0.02), 1)),
rC = rnorm(1, -3, 0.01),
y0_Log = rnorm(1, 17 , 0.1),
sigma1 = exp(rnorm(1,log(1.5), 1)),
sigma2 = exp(rnorm(1,log(1.5), 1)))
## Specify the variables for which you want history and density plots
parametersToPlot <- c("psi", "lambda0", "rC", "y0_Log", "sigma1", "sigma2")
## Additional variables to monitor
otherRVs <- c("y1_mean_pred", "countspred", "y2_mean_pred", "fdpred", "log_lik")
parameters <- c(parametersToPlot, otherRVs)
################################################################################################
## run Stan
# parameters for running fits
nChains <- 3
nPost <- 500 ## Number of post-burn-in samples per chain after thinning
nBurn <- 500 ## Number of burn-in samples per chain after thinning
nThin <- 1
nIter <- (nPost + nBurn) * nThin
nBurnin <- nBurn * nThin
fit <- stan(file = file.path(modelDir, paste(modelName, ".stan", sep = "")),
data = data,
pars = parameters,
iter = nIter,
warmup = nBurnin,
thin = nThin,
init = init,
control = list(adapt_delta = 0.9),
chains = nChains)
combined_loglik <- extract_log_lik(fit, parameter_name = "log_lik", merge_chains = TRUE)
# optional but recommended
ll_array <- extract_log_lik(fit, merge_chains = FALSE)
r_eff <- relative_eff(exp(ll_array))
# loo-ic values
loo_loglik <- loo(combined_loglik, r_eff = r_eff, save_psis = FALSE, cores = 8)
# Widely applicable AIC
AICw_lok <- waic(combined_loglik)
# AIC from LLmax
#AIC_lok <-  -2 * max(combined_loglik)  + 2 * length(parametersToPlot)
ploocv <- rbind("loo-ic"=loo_loglik$estimates[3], "WAIC" = AICw_lok$estimates[3])  #, "AIC" = AIC_lok)
ploocv[1]
### posterior distributions of parameters
ptable <- monitor(as.array(fit, pars = parametersToPlot), warmup = 0, print = FALSE)
ptable[,c(1,4,8)]
options(bayesplot.base_size = 15,
bayesplot.base_family = "sans")
color_scheme_set(scheme = "viridis")
myTheme <- theme(text = element_text(size = 12), axis.text = element_text(size = 22), axis.title =  element_text(size = 20, face = "bold"),
plot.title = element_text(size=20,  hjust = 0.5), legend.text = element_text(size=20), legend.title = element_text(size = 20))
# setting ggplot theme for rest fo the plots
theme_set(theme_bw())
fancy_scientific <- function(l) {
# turn in to character string in scientific notation
l <- format(l, scientific = TRUE)
# quote the part before the exponent to keep all the digits
l <- gsub("^(.*)e", "'\\1'e", l)
# remove + after exponent, if exists. E.g.: (e^+2 -> e^2)
l <- gsub("e\\+","e",l)
# turn the 'e' into plotmath format
l <- gsub("e", "%*%10^", l)
# convert 1x10^ or 1.000x10^ -> 10^
l <- gsub("\\'1[\\.0]*\\'\\%\\*\\%", "", l)
# return this as an expression
parse(text=l)
}
log10minorbreaks=as.numeric(1:10 %o% 10^(4:8))
ts_pred = seq(from = 0, to = 600, by = 1)
# Total cell counts
Cpred <- as.data.frame(fit, pars = "countspred") %>%
gather(factor_key = TRUE) %>%
group_by(key) %>%
summarize(lb = quantile(value, probs = 0.045),
median = quantile(value, probs = 0.5),
ub = quantile(value, probs = 0.955)) %>%
bind_cols("timeseries" = ts_pred)
Y1pred <- as.data.frame(fit, pars = "y1_mean_pred") %>%
gather(factor_key = TRUE) %>%
group_by(key) %>%
summarize(lb = quantile(value, probs = 0.045),
median = quantile(value, probs = 0.5),
ub = quantile(value, probs = 0.955)) %>%
bind_cols("timeseries" = ts_pred)
Y1pred <- Y1pred%>%
filter(timeseries >= 10)%>% filter(timeseries <= 350)
Cpred <- Cpred%>%
filter(timeseries >= 10)%>% filter(timeseries <= 350)
ggplot() +
geom_ribbon(data = Cpred, aes(x = timeseries, ymin = lb, ymax=ub), fill = '#0099cc', alpha = 0.2) +
geom_ribbon(data = Y1pred, aes(x = timeseries, ymin = lb, ymax = ub), fill = "#f23047", alpha = 0.3)+
geom_line(data = Y1pred, aes(x = timeseries, y = median), size=1.5) +
geom_point(data = counts_sorted, aes(x = time.post.BMT, y = total_counts), size=3) +
labs(title=paste('Cell counts: gdt'),  y=NULL, x= "Time post BMT (days)") +
scale_x_continuous(limits = c(10, 400) , trans="log10", breaks=c(10, 30, 100, 300))+
scale_y_continuous(limits = c(1e4, 2e6), trans="log10", breaks=c(1e4, 1e5, 1e6, 1e7, 1e8), minor_breaks = log10minorbreaks, labels =fancy_scientific) +
guides(color = FALSE) + myTheme
# normalised donr fractions
fdpred <- as.data.frame(fit, pars = "fdpred") %>%
gather(factor_key = TRUE) %>%
group_by(key) %>%
summarize(lb = quantile(value, probs = 0.045),
median = quantile(value, probs = 0.5),
ub = quantile(value, probs = 0.955)) %>%
bind_cols("timeseries" = ts_pred)
Y2pred <- as.data.frame(fit, pars = "y2_mean_pred") %>%
gather(factor_key = TRUE) %>%
group_by(key) %>%
summarize(lb = quantile(value, probs = 0.045),
median = quantile(value, probs = 0.5),
ub = quantile(value, probs = 0.955)) %>%
bind_cols("timeseries" = ts_pred)
Y2pred <- Y2pred%>%
filter(timeseries >= 0)%>% filter(timeseries <= 340)
fdpred <- fdpred%>%
filter(timeseries >= 0)%>% filter(timeseries <= 340)
ggplot() +
geom_hline(aes(yintercept = 1), color = "#d11100", linetype = 2, size=1.2)+
geom_ribbon(data = fdpred, aes(x = timeseries, ymin = lb, ymax=ub), fill = "#0099cc", alpha = 0.2) +
geom_ribbon(data = Y2pred, aes(x = timeseries, ymin = lb, ymax = ub), fill = "#f23047", alpha = 0.35)+
geom_line(data = Y2pred, aes(x = timeseries, y = median), size=1.5) +
geom_point(data = Nfd_sorted, aes(x = time.post.BMT, y = Nfd), size=3) +
labs(x = "Days post BMT", y = NULL, title = "Normalised Donor fractions: gdt") +
scale_x_continuous(limits = c(0, 350), breaks = c(0,150,300,450))+
scale_y_continuous(limits =c(-0.15, 1.2), breaks = c(0, 0.3, 0.6, 0.9, 1.2, 1.5))+
guides(color = FALSE)+ myTheme
## Simple linear ODE model -- Homogeneous model
## clearing the environment
rm(list = ls())
gc()
setwd("~/Desktop/Git_repos/GDT_dynamics")
####################################################################################
## Installing r-stan pachage on the go:
if(!("rstan" %in% rownames(installed.packages())) ){
install.packages("rstan", repos = "https://cloud.r-project.org/", dependencies=TRUE)
}
## Installing loo:
if(!("loo" %in% rownames(installed.packages())) ){
install.packages("loo", repos = "https://cloud.r-project.org/", dependencies=TRUE)
}
## Installing tidyverse:
if(!("tidyverse" %in% rownames(installed.packages())) ){
install.packages("tidyverse", repos = "https://cloud.r-project.org/", dependencies=TRUE)
}
####################################################################################
require(rstan)
require(parallel)
require(loo)
require(tidyverse)
modelName <- "TD_model"
data_derived1 <- "source_gdt.csv"    # name of the file for precursor pop
data_derived2 <- "counts_gdt.csv"
data_derived3 <- "NFd_gdt.csv"
## Setting all the directories for opeartions
projectDir <- getwd()
scriptDir <- file.path(projectDir, "scripts")
modelDir <- file.path(projectDir, "models")
dataDir <- file.path(projectDir, "data")
toolsDir <- file.path(scriptDir, "tools")
outputDir <- file.path(projectDir, "output/T1_Norm")
saveDir <- file.path(outputDir, paste(modelName, "_", substr(data_derived1, 1,2), sep=""))
# loadiong the scr# loadiong the script that contains functions for plotting stan parameters
source(file.path(toolsDir, "stanTools.R"))
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
# set different seeds for different tasks
i <- as.numeric(Sys.getenv("SLURM_PROCID"))
seed <- 4010 + i
################################################################################################
################################################################################################
source_sorted <- read_csv(file.path(dataDir, data_derived1))%>% arrange(time.post.BMT)
counts_sorted <- read_csv(file.path(dataDir, data_derived2))%>% arrange(time.post.BMT)
Nfd_sorted <- read_csv(file.path(dataDir, data_derived3))%>% arrange(time.post.BMT)
# time points in data
data_time <- counts_sorted$time.post.BMT
solve_time <- c(0, unique(data_time))   # unique time points to solve ode
#keep track of index of time point in relation to solve_time
time_index <- purrr::map_dbl(data_time, function(x) which(x == solve_time))
# time sequence for prediction
ts_pred = seq(from = 0, to = 600, by = 1)
source_list = data.frame("nu" = 0.0014307, "theta0" = 10.56, "chiEst" = 0.81, "qEst" = 0.066)
## create data set
data <- list(
numObs = nrow(counts_sorted),
Nd_0 = 0,
solve_time = solve_time,
num_index = length(solve_time),
time_index = time_index,
dpBMT = data_time,
counts = counts_sorted$total_counts,
Nfd = Nfd_sorted$Nfd,
numPred = length(ts_pred),
ts_pred = ts_pred,
theta0 = exp(source_list$theta0),
nu = source_list$nu,
chiEst = source_list$chiEst,
qEst = source_list$qEst
)
## create initial estimates
init <- function() list(
psi = exp(rnorm(1, log(0.5), 0.2)),
lambda = exp(rnorm(1,log(0.02), 1)),
rC = rnorm(1, -3, 0.01),
y0_Log = rnorm(1, 17 , 0.1),
sigma1 = exp(rnorm(1,log(1.5), 1)),
sigma2 = exp(rnorm(1,log(1.5), 1)))
## Specify the variables for which you want history and density plots
parametersToPlot <- c("psi", "lambda0", "rC", "y0_Log", "sigma1", "sigma2")
## Additional variables to monitor
otherRVs <- c("y1_mean_pred", "countspred", "y2_mean_pred", "fdpred", "log_lik")
parameters <- c(parametersToPlot, otherRVs)
################################################################################################
## run Stan
# parameters for running fits
nChains <- 3
nPost <- 500 ## Number of post-burn-in samples per chain after thinning
nBurn <- 500 ## Number of burn-in samples per chain after thinning
nThin <- 1
nIter <- (nPost + nBurn) * nThin
nBurnin <- nBurn * nThin
fit <- stan(file = file.path(modelDir, paste(modelName, ".stan", sep = "")),
data = data,
pars = parameters,
iter = nIter,
warmup = nBurnin,
thin = nThin,
init = init,
control = list(adapt_delta = 0.9),
chains = nChains)
## Simple linear ODE model -- Homogeneous model
## clearing the environment
rm(list = ls())
gc()
setwd("~/Desktop/Git_repos/GDT_dynamics")
####################################################################################
## Installing r-stan pachage on the go:
if(!("rstan" %in% rownames(installed.packages())) ){
install.packages("rstan", repos = "https://cloud.r-project.org/", dependencies=TRUE)
}
## Installing loo:
if(!("loo" %in% rownames(installed.packages())) ){
install.packages("loo", repos = "https://cloud.r-project.org/", dependencies=TRUE)
}
## Installing tidyverse:
if(!("tidyverse" %in% rownames(installed.packages())) ){
install.packages("tidyverse", repos = "https://cloud.r-project.org/", dependencies=TRUE)
}
####################################################################################
require(rstan)
require(parallel)
require(loo)
require(tidyverse)
modelName <- "TD_model"
data_derived1 <- "source_gdt.csv"    # name of the file for precursor pop
data_derived2 <- "counts_gdt.csv"
data_derived3 <- "NFd_gdt.csv"
## Setting all the directories for opeartions
projectDir <- getwd()
scriptDir <- file.path(projectDir, "scripts")
modelDir <- file.path(projectDir, "models")
dataDir <- file.path(projectDir, "data")
toolsDir <- file.path(scriptDir, "tools")
outputDir <- file.path(projectDir, "output/T1_Norm")
saveDir <- file.path(outputDir, paste(modelName, "_", substr(data_derived1, 1,2), sep=""))
# loadiong the scr# loadiong the script that contains functions for plotting stan parameters
source(file.path(toolsDir, "stanTools.R"))
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
# set different seeds for different tasks
i <- as.numeric(Sys.getenv("SLURM_PROCID"))
seed <- 4010 + i
################################################################################################
################################################################################################
source_sorted <- read_csv(file.path(dataDir, data_derived1))%>% arrange(time.post.BMT)
counts_sorted <- read_csv(file.path(dataDir, data_derived2))%>% arrange(time.post.BMT)
Nfd_sorted <- read_csv(file.path(dataDir, data_derived3))%>% arrange(time.post.BMT)
# time points in data
data_time <- counts_sorted$time.post.BMT
solve_time <- c(0, unique(data_time))   # unique time points to solve ode
#keep track of index of time point in relation to solve_time
time_index <- purrr::map_dbl(data_time, function(x) which(x == solve_time))
# time sequence for prediction
ts_pred = seq(from = 0, to = 600, by = 1)
source_list = data.frame("nu" = 0.0014307, "theta0" = 10.56, "chiEst" = 0.81, "qEst" = 0.066)
## create data set
data <- list(
numObs = nrow(counts_sorted),
Nd_0 = 0,
solve_time = solve_time,
num_index = length(solve_time),
time_index = time_index,
dpBMT = data_time,
counts = counts_sorted$total_counts,
Nfd = Nfd_sorted$Nfd,
numPred = length(ts_pred),
ts_pred = ts_pred,
theta0 = exp(source_list$theta0),
nu = source_list$nu,
chiEst = source_list$chiEst,
qEst = source_list$qEst
)
## create initial estimates
init <- function() list(
psi = exp(rnorm(1, log(0.5), 0.2)),
lambda = exp(rnorm(1,log(0.02), 1)),
rC = rnorm(1, -3, 0.01),
y0_Log = rnorm(1, 17 , 0.1),
sigma1 = exp(rnorm(1,log(1.5), 1)),
sigma2 = exp(rnorm(1,log(1.5), 1)))
## Specify the variables for which you want history and density plots
parametersToPlot <- c("psi", "lambda0", "rC", "y0_Log", "sigma1", "sigma2")
## Additional variables to monitor
otherRVs <- c("y1_mean_pred", "countspred", "y2_mean_pred", "fdpred", "log_lik")
parameters <- c(parametersToPlot, otherRVs)
################################################################################################
## run Stan
# parameters for running fits
nChains <- 3
nPost <- 500 ## Number of post-burn-in samples per chain after thinning
nBurn <- 500 ## Number of burn-in samples per chain after thinning
nThin <- 1
nIter <- (nPost + nBurn) * nThin
nBurnin <- nBurn * nThin
fit <- stan(file = file.path(modelDir, paste(modelName, ".stan", sep = "")),
data = data,
pars = parameters,
iter = nIter,
warmup = nBurnin,
thin = nThin,
init = init,
control = list(adapt_delta = 0.9),
chains = nChains)
combined_loglik <- extract_log_lik(fit, parameter_name = "log_lik", merge_chains = TRUE)
# optional but recommended
ll_array <- extract_log_lik(fit, merge_chains = FALSE)
r_eff <- relative_eff(exp(ll_array))
# loo-ic values
loo_loglik <- loo(combined_loglik, r_eff = r_eff, save_psis = FALSE, cores = 8)
# Widely applicable AIC
AICw_lok <- waic(combined_loglik)
# AIC from LLmax
#AIC_lok <-  -2 * max(combined_loglik)  + 2 * length(parametersToPlot)
ploocv <- rbind("loo-ic"=loo_loglik$estimates[3], "WAIC" = AICw_lok$estimates[3])  #, "AIC" = AIC_lok)
ploocv[1]
### posterior distributions of parameters
ptable <- monitor(as.array(fit, pars = parametersToPlot), warmup = 0, print = FALSE)
ptable[,c(1,4,8)]
ptable[,c(1,4,8)]
options(bayesplot.base_size = 15,
bayesplot.base_family = "sans")
color_scheme_set(scheme = "viridis")
myTheme <- theme(text = element_text(size = 12), axis.text = element_text(size = 22), axis.title =  element_text(size = 20, face = "bold"),
plot.title = element_text(size=20,  hjust = 0.5), legend.text = element_text(size=20), legend.title = element_text(size = 20))
# setting ggplot theme for rest fo the plots
theme_set(theme_bw())
fancy_scientific <- function(l) {
# turn in to character string in scientific notation
l <- format(l, scientific = TRUE)
# quote the part before the exponent to keep all the digits
l <- gsub("^(.*)e", "'\\1'e", l)
# remove + after exponent, if exists. E.g.: (e^+2 -> e^2)
l <- gsub("e\\+","e",l)
# turn the 'e' into plotmath format
l <- gsub("e", "%*%10^", l)
# convert 1x10^ or 1.000x10^ -> 10^
l <- gsub("\\'1[\\.0]*\\'\\%\\*\\%", "", l)
# return this as an expression
parse(text=l)
}
log10minorbreaks=as.numeric(1:10 %o% 10^(4:8))
rhats <- rhat(fit, pars = parametersToPlot)
mcmc_rhat(rhats) + yaxis_text() + myTheme
ratios1 <- neff_ratio(fit, pars = parametersToPlot)
mcmc_neff(ratios1) + yaxis_text() + myTheme
posterior <- as.array(fit)
mcmc_acf(posterior, pars = parametersToPlot) + myTheme
mcmcHistory(fit, pars = parametersToPlot, nParPerPage = 4, myTheme = myTheme)
mcmc_dens_overlay(posterior, parametersToPlot)
mcmc_dens(posterior, parametersToPlot) + myTheme
options(bayesplot.base_size = 15,
bayesplot.base_family = "sans")
color_scheme_set(scheme = "viridis")
myTheme <- theme(text = element_text(size = 12), axis.text = element_text(size = 22), axis.title =  element_text(size = 20, face = "bold"),
plot.title = element_text(size=20,  hjust = 0.5), legend.text = element_text(size=20), legend.title = element_text(size = 20))
# setting ggplot theme for rest fo the plots
theme_set(theme_bw())
fancy_scientific <- function(l) {
# turn in to character string in scientific notation
l <- format(l, scientific = TRUE)
# quote the part before the exponent to keep all the digits
l <- gsub("^(.*)e", "'\\1'e", l)
# remove + after exponent, if exists. E.g.: (e^+2 -> e^2)
l <- gsub("e\\+","e",l)
# turn the 'e' into plotmath format
l <- gsub("e", "%*%10^", l)
# convert 1x10^ or 1.000x10^ -> 10^
l <- gsub("\\'1[\\.0]*\\'\\%\\*\\%", "", l)
# return this as an expression
parse(text=l)
}
log10minorbreaks=as.numeric(1:10 %o% 10^(4:8))
rhats <- rhat(fit, pars = parametersToPlot)
mcmc_rhat(rhats) + yaxis_text() + myTheme
ratios1 <- neff_ratio(fit, pars = parametersToPlot)
mcmc_neff(ratios1) + yaxis_text() + myTheme
posterior <- as.array(fit)
mcmc_acf(posterior, pars = parametersToPlot) + myTheme
mcmcHistory(fit, pars = parametersToPlot, nParPerPage = 4, myTheme = myTheme)
mcmc_dens_overlay(posterior, parametersToPlot)
mcmc_dens(posterior, parametersToPlot) + myTheme
ts_pred = seq(from = 0, to = 600, by = 1)
# Total cell counts
Cpred <- as.data.frame(fit, pars = "countspred") %>%
gather(factor_key = TRUE) %>%
group_by(key) %>%
summarize(lb = quantile(value, probs = 0.045),
median = quantile(value, probs = 0.5),
ub = quantile(value, probs = 0.955)) %>%
bind_cols("timeseries" = ts_pred)
Y1pred <- as.data.frame(fit, pars = "y1_mean_pred") %>%
gather(factor_key = TRUE) %>%
group_by(key) %>%
summarize(lb = quantile(value, probs = 0.045),
median = quantile(value, probs = 0.5),
ub = quantile(value, probs = 0.955)) %>%
bind_cols("timeseries" = ts_pred)
Y1pred <- Y1pred%>%
filter(timeseries >= 10)%>% filter(timeseries <= 350)
Cpred <- Cpred%>%
filter(timeseries >= 10)%>% filter(timeseries <= 350)
ggplot() +
geom_ribbon(data = Cpred, aes(x = timeseries, ymin = lb, ymax=ub), fill = '#0099cc', alpha = 0.2) +
geom_ribbon(data = Y1pred, aes(x = timeseries, ymin = lb, ymax = ub), fill = "#f23047", alpha = 0.3)+
geom_line(data = Y1pred, aes(x = timeseries, y = median), size=1.5) +
geom_point(data = counts_sorted, aes(x = time.post.BMT, y = total_counts), size=3) +
labs(title=paste('Cell counts: gdt'),  y=NULL, x= "Time post BMT (days)") +
scale_x_continuous(limits = c(10, 400) , trans="log10", breaks=c(10, 30, 100, 300))+
scale_y_continuous(limits = c(1e4, 2e6), trans="log10", breaks=c(1e4, 1e5, 1e6, 1e7, 1e8), minor_breaks = log10minorbreaks, labels =fancy_scientific) +
guides(color = FALSE) + myTheme
ts_pred = seq(from = 0, to = 600, by = 1)
# Total cell counts
Cpred <- as.data.frame(fit, pars = "countspred") %>%
gather(factor_key = TRUE) %>%
group_by(key) %>%
summarize(lb = quantile(value, probs = 0.045),
median = quantile(value, probs = 0.5),
ub = quantile(value, probs = 0.955)) %>%
bind_cols("timeseries" = ts_pred)
Y1pred <- as.data.frame(fit, pars = "y1_mean_pred") %>%
gather(factor_key = TRUE) %>%
group_by(key) %>%
summarize(lb = quantile(value, probs = 0.045),
median = quantile(value, probs = 0.5),
ub = quantile(value, probs = 0.955)) %>%
bind_cols("timeseries" = ts_pred)
Y1pred <- Y1pred%>%
filter(timeseries >= 10)%>% filter(timeseries <= 350)
Cpred <- Cpred%>%
filter(timeseries >= 10)%>% filter(timeseries <= 350)
ggplot() +
geom_ribbon(data = Cpred, aes(x = timeseries, ymin = lb, ymax=ub), fill = '#0099cc', alpha = 0.2) +
geom_ribbon(data = Y1pred, aes(x = timeseries, ymin = lb, ymax = ub), fill = "#f23047", alpha = 0.3)+
geom_line(data = Y1pred, aes(x = timeseries, y = median), size=1.5) +
geom_point(data = counts_sorted, aes(x = time.post.BMT, y = total_counts), size=3) +
labs(title=paste('Cell counts: gdt'),  y=NULL, x= "Time post BMT (days)") +
scale_x_continuous(limits = c(10, 400) , trans="log10", breaks=c(10, 30, 100, 300))+
scale_y_continuous(limits = c(1e4, 2e6), trans="log10", breaks=c(1e4, 1e5, 1e6, 1e7, 1e8), minor_breaks = log10minorbreaks, labels =fancy_scientific) +
guides(color = FALSE) + myTheme
# normalised donr fractions
fdpred <- as.data.frame(fit, pars = "fdpred") %>%
gather(factor_key = TRUE) %>%
group_by(key) %>%
summarize(lb = quantile(value, probs = 0.045),
median = quantile(value, probs = 0.5),
ub = quantile(value, probs = 0.955)) %>%
bind_cols("timeseries" = ts_pred)
Y2pred <- as.data.frame(fit, pars = "y2_mean_pred") %>%
gather(factor_key = TRUE) %>%
group_by(key) %>%
summarize(lb = quantile(value, probs = 0.045),
median = quantile(value, probs = 0.5),
ub = quantile(value, probs = 0.955)) %>%
bind_cols("timeseries" = ts_pred)
Y2pred <- Y2pred%>%
filter(timeseries >= 0)%>% filter(timeseries <= 340)
fdpred <- fdpred%>%
filter(timeseries >= 0)%>% filter(timeseries <= 340)
ggplot() +
geom_hline(aes(yintercept = 1), color = "#d11100", linetype = 2, size=1.2)+
geom_ribbon(data = fdpred, aes(x = timeseries, ymin = lb, ymax=ub), fill = "#0099cc", alpha = 0.2) +
geom_ribbon(data = Y2pred, aes(x = timeseries, ymin = lb, ymax = ub), fill = "#f23047", alpha = 0.35)+
geom_line(data = Y2pred, aes(x = timeseries, y = median), size=1.5) +
geom_point(data = Nfd_sorted, aes(x = time.post.BMT, y = Nfd), size=3) +
labs(x = "Days post BMT", y = NULL, title = "Normalised Donor fractions: gdt") +
scale_x_continuous(limits = c(0, 350), breaks = c(0,150,300,450))+
scale_y_continuous(limits =c(-0.15, 1.2), breaks = c(0, 0.3, 0.6, 0.9, 1.2, 1.5))+
guides(color = FALSE)+ myTheme
ptable[,c(1,4,8)]
